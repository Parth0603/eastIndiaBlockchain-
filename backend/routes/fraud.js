import express from 'express';
import { authenticateToken, requireAdmin, requireVerifier } from '../middleware/auth.js';
import FraudReport from '../models/FraudReport.js';
import Transaction from '../models/Transaction.js';
import Vendor from '../models/Vendor.js';
import User from '../models/User.js';
import fraudDetectionService from '../services/fraudDetection.js';

const router = express.Router();

/**
 * @route   POST /api/fraud/report
 * @desc    Submit a fraud report
 * @access  Private (Any authenticated user)
 */
router.post('/report',
  authenticateToken,
  async (req, res) => {
    try {
      const {
        reportedEntity,
        entityType,
        reportType,
        severity,
        description,
        evidence,
        relatedTransactions,
        isAnonymous
      } = req.body;

      // Validate required fields
      if (!reportedEntity || !entityType || !reportType || !description) {
        return res.status(400).json({
          success: false,
          message: 'Missing required fields: reportedEntity, entityType, reportType, description'
        });
      }

      // Validate reported entity exists
      let entityExists = false;
      switch (entityType) {
        case 'vendor':
          entityExists = await Vendor.findOne({ address: reportedEntity.toLowerCase() });
          break;
        case 'beneficiary':
        case 'verifier':
          entityExists = await User.findOne({ 
            address: reportedEntity.toLowerCase(),
            role: entityType
          });
          break;
      }

      if (!entityExists) {
        return res.status(404).json({
          success: false,
          message: `${entityType} not found`
        });
      }

      // Create fraud report
      const fraudReport = new FraudReport({
        reportedEntity: reportedEntity.toLowerCase(),
        entityType,
        reportType,
        severity: severity || 'medium',
        description,
        evidence: evidence || [],
        relatedTransactions: relatedTransactions || [],
        reportedBy: {
          address: isAnonymous ? null : req.user.address,
          role: req.user.role,
          isAnonymous: isAnonymous || false
        },
        autoGenerated: false,
        detectionMethod: 'manual_report'
      });

      await fraudReport.save();

      // If high severity, auto-flag the entity
      if (severity === 'high' || severity === 'critical') {
        if (entityType === 'vendor') {
          await fraudDetectionService.flagVendor(
            reportedEntity,
            `Manual fraud report: ${reportType}`,
            severity,
            req.user.address
          );
        }
      }

      // Emit real-time notification
      const websocketService = req.app.get('websocket');
      if (websocketService) {
        websocketService.notifyFraudAlert({
          reportId: fraudReport.reportId,
          type: reportType,
          severity: severity || 'medium',
          entityType,
          reportedEntity
        });
      }

      res.status(201).json({
        success: true,
        message: 'Fraud report submitted successfully',
        data: {
          reportId: fraudReport.reportId,
          status: fraudReport.status,
          priority: fraudReport.priority
        }
      });

    } catch (error) {
      console.error('Submit fraud report error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to submit fraud report',
        error: error.message
      });
    }
  }
);

/**
 * @route   GET /api/fraud/reports
 * @desc    Get fraud reports (admin/verifier only)
 * @access  Private (Admin/Verifier)
 */
router.get('/reports',
  authenticateToken,
  requireVerifier,
  async (req, res) => {
    try {
      const {
        page = 1,
        limit = 20,
        status,
        severity,
        entityType,
        reportType,
        assignedTo
      } = req.query;

      const skip = (page - 1) * limit;

      // Build query
      const query = {};
      if (status) query.status = status;
      if (severity) query.severity = severity;
      if (entityType) query.entityType = entityType;
      if (reportType) query.reportType = reportType;
      if (assignedTo) query.assignedTo = assignedTo.toLowerCase();

      // If user is verifier (not admin), only show assigned reports
      if (req.user.role === 'verifier') {
        query.assignedTo = req.user.address;
      }

      const reports = await FraudReport.find(query)
        .sort({ priority: -1, createdAt: -1 })
        .skip(skip)
        .limit(parseInt(limit))
        .lean();

      const total = await FraudReport.countDocuments(query);

      // Get summary statistics
      const summary = await FraudReport.aggregate([
        { $match: query },
        {
          $group: {
            _id: '$status',
            count: { $sum: 1 }
          }
        }
      ]);

      res.json({
        success: true,
        data: {
          reports: reports.map(report => ({
            ...report,
            // Hide sensitive information for non-admin users
            reportedBy: req.user.role === 'admin' ? report.reportedBy : {
              role: report.reportedBy?.role,
              isAnonymous: report.reportedBy?.isAnonymous
            }
          })),
          pagination: {
            page: parseInt(page),
            limit: parseInt(limit),
            total,
            pages: Math.ceil(total / limit)
          },
          summary: summary.reduce((acc, item) => {
            acc[item._id] = item.count;
            return acc;
          }, {})
        }
      });

    } catch (error) {
      console.error('Get fraud reports error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to get fraud reports',
        error: error.message
      });
    }
  }
);

/**
 * @route   GET /api/fraud/reports/:reportId
 * @desc    Get specific fraud report details
 * @access  Private (Admin/Verifier)
 */
router.get('/reports/:reportId',
  authenticateToken,
  requireVerifier,
  async (req, res) => {
    try {
      const { reportId } = req.params;

      const report = await FraudReport.findOne({ reportId })
        .populate('relatedTransactions.transactionId');

      if (!report) {
        return res.status(404).json({
          success: false,
          message: 'Fraud report not found'
        });
      }

      // Check access permissions
      if (req.user.role === 'verifier' && report.assignedTo !== req.user.address) {
        return res.status(403).json({
          success: false,
          message: 'Access denied to this report'
        });
      }

      res.json({
        success: true,
        data: report
      });

    } catch (error) {
      console.error('Get fraud report details error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to get fraud report details',
        error: error.message
      });
    }
  }
);

/**
 * @route   PUT /api/fraud/reports/:reportId/assign
 * @desc    Assign fraud report to investigator
 * @access  Private (Admin only)
 */
router.put('/reports/:reportId/assign',
  authenticateToken,
  requireAdmin,
  async (req, res) => {
    try {
      const { reportId } = req.params;
      const { investigatorAddress } = req.body;

      if (!investigatorAddress) {
        return res.status(400).json({
          success: false,
          message: 'Investigator address is required'
        });
      }

      // Validate investigator exists and has appropriate role
      const investigator = await User.findOne({
        address: investigatorAddress.toLowerCase(),
        role: { $in: ['admin', 'verifier'] }
      });

      if (!investigator) {
        return res.status(404).json({
          success: false,
          message: 'Investigator not found or invalid role'
        });
      }

      const report = await FraudReport.findOne({ reportId });
      if (!report) {
        return res.status(404).json({
          success: false,
          message: 'Fraud report not found'
        });
      }

      report.assignInvestigator(investigatorAddress, req.user.address);
      report.status = 'under_investigation';
      await report.save();

      res.json({
        success: true,
        message: 'Report assigned successfully',
        data: {
          reportId: report.reportId,
          assignedTo: report.assignedTo,
          status: report.status
        }
      });

    } catch (error) {
      console.error('Assign fraud report error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to assign fraud report',
        error: error.message
      });
    }
  }
);

/**
 * @route   PUT /api/fraud/reports/:reportId/investigate
 * @desc    Add investigation notes and update status
 * @access  Private (Admin/Assigned Verifier)
 */
router.put('/reports/:reportId/investigate',
  authenticateToken,
  requireVerifier,
  async (req, res) => {
    try {
      const { reportId } = req.params;
      const { notes, status, evidence } = req.body;

      const report = await FraudReport.findOne({ reportId });
      if (!report) {
        return res.status(404).json({
          success: false,
          message: 'Fraud report not found'
        });
      }

      // Check access permissions
      if (req.user.role === 'verifier' && report.assignedTo !== req.user.address) {
        return res.status(403).json({
          success: false,
          message: 'Access denied to this report'
        });
      }

      // Add investigation notes
      if (notes) {
        report.addInvestigationNote(notes, req.user.address, false);
      }

      // Add evidence if provided
      if (evidence && Array.isArray(evidence)) {
        evidence.forEach(ev => {
          report.addEvidence(ev.type, ev.description, ev.data, req.user.address);
        });
      }

      // Update status if provided
      if (status && ['under_investigation', 'escalated', 'resolved', 'dismissed'].includes(status)) {
        report.updateStatus(status, req.user.address, notes);
      }

      await report.save();

      res.json({
        success: true,
        message: 'Investigation updated successfully',
        data: {
          reportId: report.reportId,
          status: report.status,
          notesCount: report.investigationNotes.length,
          evidenceCount: report.evidence.length
        }
      });

    } catch (error) {
      console.error('Update investigation error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to update investigation',
        error: error.message
      });
    }
  }
);

/**
 * @route   PUT /api/fraud/reports/:reportId/resolve
 * @desc    Resolve fraud report with decision and action
 * @access  Private (Admin/Assigned Verifier)
 */
router.put('/reports/:reportId/resolve',
  authenticateToken,
  requireVerifier,
  async (req, res) => {
    try {
      const { reportId } = req.params;
      const { decision, action, description } = req.body;

      if (!decision || !action) {
        return res.status(400).json({
          success: false,
          message: 'Decision and action are required'
        });
      }

      const report = await FraudReport.findOne({ reportId });
      if (!report) {
        return res.status(404).json({
          success: false,
          message: 'Fraud report not found'
        });
      }

      // Check access permissions
      if (req.user.role === 'verifier' && report.assignedTo !== req.user.address) {
        return res.status(403).json({
          success: false,
          message: 'Access denied to this report'
        });
      }

      // Resolve the report
      report.resolve(decision, action, description, req.user.address);

      // Execute the action if confirmed fraud
      if (decision === 'confirmed_fraud') {
        await this.executeFraudAction(report, action);
      }

      await report.save();

      res.json({
        success: true,
        message: 'Fraud report resolved successfully',
        data: {
          reportId: report.reportId,
          decision: report.resolution.decision,
          action: report.resolution.action,
          resolvedAt: report.resolution.resolvedAt
        }
      });

    } catch (error) {
      console.error('Resolve fraud report error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to resolve fraud report',
        error: error.message
      });
    }
  }
);

/**
 * @route   GET /api/fraud/statistics
 * @desc    Get fraud detection statistics
 * @access  Private (Admin/Verifier)
 */
router.get('/statistics',
  authenticateToken,
  requireVerifier,
  async (req, res) => {
    try {
      const { timeframe = '30d' } = req.query;

      // Get fraud detection statistics
      const fraudStats = await fraudDetectionService.getFraudStatistics(timeframe);

      // Get report statistics
      const reportStats = await FraudReport.getStatistics(
        timeframe === '7d' ? 7 : timeframe === '30d' ? 30 : 90
      );

      // Get flagged transactions
      const flaggedTransactions = await Transaction.getFraudStatistics(
        timeframe === '7d' ? 7 : timeframe === '30d' ? 30 : 90
      );

      // Get trends
      const trends = await FraudReport.getFraudTrends(
        timeframe === '7d' ? 7 : timeframe === '30d' ? 30 : 90
      );

      res.json({
        success: true,
        data: {
          timeframe,
          fraudDetection: fraudStats,
          reports: reportStats,
          transactions: flaggedTransactions,
          trends: trends,
          summary: {
            totalReports: reportStats.reduce((sum, stat) => sum + stat.count, 0),
            totalFlaggedTransactions: flaggedTransactions.reduce((sum, stat) => sum + stat.flagged, 0),
            avgResolutionTime: reportStats.reduce((sum, stat) => sum + (stat.avgResolutionTime || 0), 0) / reportStats.length || 0
          }
        }
      });

    } catch (error) {
      console.error('Get fraud statistics error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to get fraud statistics',
        error: error.message
      });
    }
  }
);

/**
 * @route   GET /api/fraud/flagged-transactions
 * @desc    Get flagged transactions requiring review
 * @access  Private (Admin/Verifier)
 */
router.get('/flagged-transactions',
  authenticateToken,
  requireVerifier,
  async (req, res) => {
    try {
      const { page = 1, limit = 20, riskLevel } = req.query;
      const skip = (page - 1) * limit;

      // Get flagged transactions
      const transactions = await Transaction.findFlaggedTransactions(riskLevel)
        .skip(skip)
        .limit(parseInt(limit))
        .lean();

      // Get transactions requiring review
      const reviewTransactions = await Transaction.findTransactionsRequiringReview()
        .limit(10)
        .lean();

      const total = await Transaction.countDocuments({
        'metadata.fraudFlags': { $exists: true, $ne: [] },
        ...(riskLevel && { 'metadata.riskLevel': riskLevel })
      });

      res.json({
        success: true,
        data: {
          flaggedTransactions: transactions.map(tx => ({
            id: tx._id,
            txHash: tx.txHash,
            from: tx.from,
            to: tx.to,
            amount: (parseFloat(tx.amount) / Math.pow(10, 18)).toFixed(6),
            type: tx.type,
            category: tx.category,
            status: tx.status,
            riskLevel: tx.metadata?.riskLevel,
            fraudFlags: tx.metadata?.fraudFlags,
            requiresReview: tx.metadata?.requiresReview,
            createdAt: tx.createdAt
          })),
          requiresReview: reviewTransactions.map(tx => ({
            id: tx._id,
            txHash: tx.txHash,
            from: tx.from,
            to: tx.to,
            amount: (parseFloat(tx.amount) / Math.pow(10, 18)).toFixed(6),
            riskLevel: tx.metadata?.riskLevel,
            fraudFlags: tx.metadata?.fraudFlags,
            createdAt: tx.createdAt
          })),
          pagination: {
            page: parseInt(page),
            limit: parseInt(limit),
            total,
            pages: Math.ceil(total / limit)
          }
        }
      });

    } catch (error) {
      console.error('Get flagged transactions error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to get flagged transactions',
        error: error.message
      });
    }
  }
);

/**
 * @route   PUT /api/fraud/transactions/:transactionId/review
 * @desc    Review and approve/reject a flagged transaction
 * @access  Private (Admin/Verifier)
 */
router.put('/transactions/:transactionId/review',
  authenticateToken,
  requireVerifier,
  async (req, res) => {
    try {
      const { transactionId } = req.params;
      const { decision, notes } = req.body; // decision: 'approve' or 'reject'

      if (!decision || !['approve', 'reject'].includes(decision)) {
        return res.status(400).json({
          success: false,
          message: 'Valid decision (approve/reject) is required'
        });
      }

      const transaction = await Transaction.findById(transactionId);
      if (!transaction) {
        return res.status(404).json({
          success: false,
          message: 'Transaction not found'
        });
      }

      // Mark as reviewed
      transaction.markReviewed(req.user.address, notes);

      // Update status based on decision
      if (decision === 'reject') {
        transaction.status = 'failed';
        
        // Flag vendor if it's a vendor payment
        if (transaction.type === 'vendor_payment') {
          await fraudDetectionService.flagVendor(
            transaction.to,
            'Transaction rejected after manual review',
            'medium',
            req.user.address
          );
        }
      } else {
        // If approved, allow transaction to proceed (status remains pending for blockchain processing)
        transaction.metadata.riskLevel = 'low';
      }

      await transaction.save();

      res.json({
        success: true,
        message: `Transaction ${decision}d successfully`,
        data: {
          transactionId: transaction._id,
          decision,
          status: transaction.status,
          reviewedBy: transaction.metadata.reviewedBy,
          reviewedAt: transaction.metadata.reviewedAt
        }
      });

    } catch (error) {
      console.error('Review transaction error:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to review transaction',
        error: error.message
      });
    }
  }
);

/**
 * Execute fraud action (helper method)
 */
async function executeFraudAction(report, action) {
  try {
    switch (action) {
      case 'temporary_suspension':
      case 'permanent_ban':
        if (report.entityType === 'vendor') {
          await Vendor.findOneAndUpdate(
            { address: report.reportedEntity },
            { 
              status: action === 'permanent_ban' ? 'rejected' : 'suspended',
              reviewNotes: `Fraud action: ${action} - Report: ${report.reportId}`
            }
          );
        } else {
          await User.findOneAndUpdate(
            { address: report.reportedEntity },
            { 
              'profile.verificationStatus': 'suspended',
              'profile.suspensionReason': `Fraud action: ${action} - Report: ${report.reportId}`
            }
          );
        }
        break;
      
      case 'warning_issued':
        // Add warning to user/vendor profile
        if (report.entityType === 'vendor') {
          const vendor = await Vendor.findOne({ address: report.reportedEntity });
          if (vendor) {
            vendor.flagSuspiciousActivity();
            await vendor.save();
          }
        }
        break;
      
      // Other actions would be implemented here
      default:
        console.log(`Fraud action ${action} not implemented`);
    }
  } catch (error) {
    console.error('Execute fraud action error:', error);
    throw error;
  }
}

export default router;