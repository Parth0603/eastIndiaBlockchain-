import mongoose from 'mongoose';

const fraudReportSchema = new mongoose.Schema({
  // Report identification
  reportId: {
    type: String,
    unique: true,
    required: true,
    default: function() {
      return 'FR-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    }
  },

  // Reported entity information
  reportedEntity: {
    type: String,
    required: true,
    lowercase: true,
    validate: {
      validator: function(v) {
        return /^0x[a-fA-F0-9]{40}$/.test(v);
      },
      message: 'Invalid Ethereum address format'
    }
  },

  entityType: {
    type: String,
    enum: ['vendor', 'beneficiary', 'verifier'],
    required: true
  },

  // Report details
  reportType: {
    type: String,
    enum: [
      'fraudulent_transaction',
      'fake_documents',
      'price_manipulation',
      'collusion',
      'identity_theft',
      'duplicate_claims',
      'suspicious_behavior',
      'other'
    ],
    required: true
  },

  severity: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    default: 'medium'
  },

  description: {
    type: String,
    required: true,
    maxlength: 2000,
    trim: true
  },

  // Evidence and supporting data
  evidence: [{
    type: {
      type: String,
      enum: ['transaction_hash', 'document', 'screenshot', 'witness_statement', 'pattern_analysis', 'other']
    },
    description: String,
    data: String, // Could be hash, URL, or serialized data
    uploadedAt: {
      type: Date,
      default: Date.now
    }
  }],

  // Related transactions
  relatedTransactions: [{
    transactionId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Transaction'
    },
    txHash: String,
    relevance: String // How this transaction relates to the fraud
  }],

  // Reporter information
  reportedBy: {
    address: {
      type: String,
      lowercase: true,
      validate: {
        validator: function(v) {
          return !v || /^0x[a-fA-F0-9]{40}$/.test(v);
        },
        message: 'Invalid reporter address format'
      }
    },
    role: {
      type: String,
      enum: ['admin', 'verifier', 'beneficiary', 'vendor', 'public', 'system']
    },
    isAnonymous: {
      type: Boolean,
      default: false
    }
  },

  // System-generated flags
  autoGenerated: {
    type: Boolean,
    default: false
  },

  detectionMethod: {
    type: String,
    enum: ['manual_report', 'pattern_analysis', 'duplicate_detection', 'threshold_violation', 'ml_detection'],
    default: 'manual_report'
  },

  fraudPatterns: [{
    pattern: String,
    confidence: Number, // 0-1 confidence score
    description: String
  }],

  // Investigation status
  status: {
    type: String,
    enum: ['pending', 'under_investigation', 'resolved', 'dismissed', 'escalated'],
    default: 'pending'
  },

  priority: {
    type: String,
    enum: ['low', 'normal', 'high', 'urgent'],
    default: 'normal'
  },

  // Investigation details
  assignedTo: {
    type: String, // Investigator wallet address
    lowercase: true
  },

  investigationNotes: [{
    note: String,
    addedBy: String, // Investigator address
    addedAt: {
      type: Date,
      default: Date.now
    },
    isPublic: {
      type: Boolean,
      default: false
    }
  }],

  // Resolution
  resolution: {
    decision: {
      type: String,
      enum: ['confirmed_fraud', 'false_positive', 'insufficient_evidence', 'resolved_warning']
    },
    action: {
      type: String,
      enum: ['no_action', 'warning_issued', 'temporary_suspension', 'permanent_ban', 'funds_frozen', 'legal_action']
    },
    description: String,
    resolvedBy: String, // Resolver address
    resolvedAt: Date
  },

  // Impact assessment
  impact: {
    financialLoss: {
      type: String, // Store as string for large numbers
      default: '0'
    },
    affectedUsers: {
      type: Number,
      default: 0
    },
    systemImpact: {
      type: String,
      enum: ['none', 'minimal', 'moderate', 'significant', 'severe']
    }
  },

  // Follow-up actions
  followUpActions: [{
    action: String,
    dueDate: Date,
    assignedTo: String,
    completed: {
      type: Boolean,
      default: false
    },
    completedAt: Date
  }],

  // Metadata
  tags: [String], // For categorization and search
  
  isPublic: {
    type: Boolean,
    default: false // Most fraud reports should be private
  },

  // Audit trail
  auditTrail: [{
    action: String,
    performedBy: String,
    timestamp: {
      type: Date,
      default: Date.now
    },
    details: mongoose.Schema.Types.Mixed
  }]
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

// Indexes for performance
fraudReportSchema.index({ reportId: 1 });
fraudReportSchema.index({ reportedEntity: 1 });
fraudReportSchema.index({ status: 1, priority: -1 });
fraudReportSchema.index({ reportType: 1 });
fraudReportSchema.index({ severity: 1 });
fraudReportSchema.index({ createdAt: -1 });
fraudReportSchema.index({ assignedTo: 1, status: 1 });
fraudReportSchema.index({ 'reportedBy.address': 1 });

// Compound indexes
fraudReportSchema.index({ entityType: 1, status: 1 });
fraudReportSchema.index({ reportType: 1, severity: 1 });

// Virtual for days since report
fraudReportSchema.virtual('daysSinceReport').get(function() {
  return Math.floor((Date.now() - this.createdAt) / (1000 * 60 * 60 * 24));
});

// Virtual for resolution time
fraudReportSchema.virtual('resolutionTime').get(function() {
  if (this.resolution?.resolvedAt) {
    return Math.floor((this.resolution.resolvedAt - this.createdAt) / (1000 * 60 * 60 * 24));
  }
  return null;
});

// Instance methods
fraudReportSchema.methods.addInvestigationNote = function(note, addedBy, isPublic = false) {
  this.investigationNotes.push({
    note,
    addedBy: addedBy.toLowerCase(),
    isPublic
  });
  
  this.addAuditEntry('note_added', addedBy, { noteLength: note.length, isPublic });
};

fraudReportSchema.methods.updateStatus = function(newStatus, updatedBy, reason = '') {
  const oldStatus = this.status;
  this.status = newStatus;
  
  this.addAuditEntry('status_changed', updatedBy, {
    oldStatus,
    newStatus,
    reason
  });
};

fraudReportSchema.methods.assignInvestigator = function(investigatorAddress, assignedBy) {
  this.assignedTo = investigatorAddress.toLowerCase();
  this.addAuditEntry('assigned', assignedBy, { investigator: investigatorAddress });
};

fraudReportSchema.methods.resolve = function(decision, action, description, resolvedBy) {
  this.resolution = {
    decision,
    action,
    description,
    resolvedBy: resolvedBy.toLowerCase(),
    resolvedAt: new Date()
  };
  
  this.status = 'resolved';
  this.addAuditEntry('resolved', resolvedBy, { decision, action });
};

fraudReportSchema.methods.addAuditEntry = function(action, performedBy, details = {}) {
  this.auditTrail.push({
    action,
    performedBy: performedBy.toLowerCase(),
    details
  });
};

fraudReportSchema.methods.addEvidence = function(evidenceType, description, data, addedBy) {
  this.evidence.push({
    type: evidenceType,
    description,
    data
  });
  
  this.addAuditEntry('evidence_added', addedBy, { evidenceType, description });
};

// Static methods
fraudReportSchema.statics.findByEntity = function(entityAddress) {
  return this.find({ reportedEntity: entityAddress.toLowerCase() })
    .sort({ createdAt: -1 });
};

fraudReportSchema.statics.findPendingReports = function() {
  return this.find({ 
    status: { $in: ['pending', 'under_investigation'] } 
  }).sort({ priority: -1, createdAt: 1 });
};

fraudReportSchema.statics.findByInvestigator = function(investigatorAddress) {
  return this.find({ 
    assignedTo: investigatorAddress.toLowerCase(),
    status: { $in: ['under_investigation', 'pending'] }
  }).sort({ priority: -1, createdAt: 1 });
};

fraudReportSchema.statics.getStatistics = function(timeframe = 30) {
  const startDate = new Date(Date.now() - timeframe * 24 * 60 * 60 * 1000);
  
  return this.aggregate([
    { $match: { createdAt: { $gte: startDate } } },
    {
      $group: {
        _id: '$status',
        count: { $sum: 1 },
        avgResolutionTime: { $avg: '$resolutionTime' }
      }
    }
  ]);
};

fraudReportSchema.statics.getFraudTrends = function(days = 30) {
  const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000);
  
  return this.aggregate([
    { $match: { createdAt: { $gte: startDate } } },
    {
      $group: {
        _id: {
          date: { $dateToString: { format: '%Y-%m-%d', date: '$createdAt' } },
          type: '$reportType'
        },
        count: { $sum: 1 }
      }
    },
    { $sort: { '_id.date': 1 } }
  ]);
};

// Pre-save middleware
fraudReportSchema.pre('save', function(next) {
  // Ensure addresses are lowercase
  if (this.reportedEntity) {
    this.reportedEntity = this.reportedEntity.toLowerCase();
  }
  
  if (this.reportedBy?.address) {
    this.reportedBy.address = this.reportedBy.address.toLowerCase();
  }
  
  if (this.assignedTo) {
    this.assignedTo = this.assignedTo.toLowerCase();
  }
  
  // Auto-set priority based on severity
  if (this.isNew) {
    switch (this.severity) {
      case 'critical':
        this.priority = 'urgent';
        break;
      case 'high':
        this.priority = 'high';
        break;
      case 'medium':
        this.priority = 'normal';
        break;
      default:
        this.priority = 'low';
    }
  }
  
  next();
});

const FraudReport = mongoose.model('FraudReport', fraudReportSchema);

export default FraudReport;